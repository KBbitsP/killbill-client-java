/*
 * Copyright 2010-2014 Ning, Inc.
 * Copyright 2014-2020 Groupon, Inc
 * Copyright 2020-2021 Equinix, Inc
 * Copyright 2014-2021 The Billing Project, LLC
 *
 * The Billing Project licenses this file to you under the Apache License, version 2.0
 * (the "License"); you may not use this file except in compliance with the
 * License.  You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */


package org.killbill.billing.client.api.gen;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.Objects;

import org.killbill.billing.client.model.gen.AdminPayment;
import java.util.UUID;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.http.HttpResponse;
import java.util.Map;

import org.killbill.billing.client.Converter;
import org.killbill.billing.client.KillBillClientException;
import org.killbill.billing.client.KillBillHttpClient;
import org.killbill.billing.client.RequestOptions;
import org.killbill.billing.client.RequestOptions.RequestOptionsBuilder;


/**
 *           DO NOT EDIT !!!
 *
 * This code has been generated by the Kill Bill swagger generator.
 *  @See https://github.com/killbill/killbill-swagger-coden
 */
public class AdminApi {

    private final KillBillHttpClient httpClient;

    public AdminApi() {
        this(new KillBillHttpClient());
    }

    public AdminApi(final KillBillHttpClient httpClient) {
        this.httpClient = httpClient;
    }

    private <K, V> void addToMapValues(final Map<K, Collection<V>> map, final K key, final Collection<V> values) {
        if (map.containsKey(key)) {
            map.get(key).addAll(values);
        } else {
            map.put(key, values);
        }
    }

    public static <T> T checkNotNull(final T reference, final Object errorMessage) {
        if (reference == null) {
            throw new NullPointerException(String.valueOf(errorMessage));
        }
        return reference;
    }

    public int getQueueEntries(final UUID accountId, final String queueName, final String serviceName, final String minDate, final String maxDate, final OutputStream outputStream, final RequestOptions inputOptions) throws KillBillClientException {
        return getQueueEntries(accountId, queueName, serviceName, Boolean.valueOf(true), minDate, maxDate, Boolean.valueOf(true), Boolean.valueOf(true), Boolean.valueOf(true), outputStream, inputOptions);
    }

    public int getQueueEntries(final UUID accountId, final String queueName, final String serviceName, final Boolean withHistory, final String minDate, final String maxDate, final Boolean withInProcessing, final Boolean withBusEvents, final Boolean withNotifications, final OutputStream outputStream, final RequestOptions inputOptions) throws KillBillClientException {

        final String uri = "/1.0/kb/admin/queues";

        final Map<String, Collection<String>> queryParams = new HashMap<>(inputOptions.getQueryParams());
        if (accountId != null) {
            addToMapValues(queryParams, "accountId", List.of(String.valueOf(accountId)));
        }
        if (queueName != null) {
            addToMapValues(queryParams, "queueName", List.of(String.valueOf(queueName)));
        }
        if (serviceName != null) {
            addToMapValues(queryParams, "serviceName", List.of(String.valueOf(serviceName)));
        }
        if (withHistory != null) {
            addToMapValues(queryParams, "withHistory", List.of(String.valueOf(withHistory)));
        }
        if (minDate != null) {
            addToMapValues(queryParams, "minDate", List.of(String.valueOf(minDate)));
        }
        if (maxDate != null) {
            addToMapValues(queryParams, "maxDate", List.of(String.valueOf(maxDate)));
        }
        if (withInProcessing != null) {
            addToMapValues(queryParams, "withInProcessing", List.of(String.valueOf(withInProcessing)));
        }
        if (withBusEvents != null) {
            addToMapValues(queryParams, "withBusEvents", List.of(String.valueOf(withBusEvents)));
        }
        if (withNotifications != null) {
            addToMapValues(queryParams, "withNotifications", List.of(String.valueOf(withNotifications)));
        }

        final RequestOptionsBuilder inputOptionsBuilder = inputOptions.extend();
        inputOptionsBuilder.withQueryParams(queryParams);
        inputOptionsBuilder.withHeader(KillBillHttpClient.HTTP_HEADER_ACCEPT, "application/octet-stream");
        final RequestOptions requestOptions = inputOptionsBuilder.build();

        final HttpResponse<InputStream> response = httpClient.doGet(uri, outputStream, requestOptions);
        return response.statusCode();
    }


    public void invalidatesCache(final String cacheName, final RequestOptions inputOptions) throws KillBillClientException {

        final String uri = "/1.0/kb/admin/cache";

        final Map<String, Collection<String>> queryParams = new HashMap<>(inputOptions.getQueryParams());
        if (cacheName != null) {
            addToMapValues(queryParams, "cacheName", List.of(String.valueOf(cacheName)));
        }

        final RequestOptionsBuilder inputOptionsBuilder = inputOptions.extend();
        inputOptionsBuilder.withQueryParams(queryParams);
        inputOptionsBuilder.withHeader(KillBillHttpClient.HTTP_HEADER_ACCEPT, "application/json");
        final RequestOptions requestOptions = inputOptionsBuilder.build();

        httpClient.doDelete(uri, requestOptions);
    }


    public void invalidatesCacheByAccount(final UUID accountId, final RequestOptions inputOptions) throws KillBillClientException {
        checkNotNull(accountId, "Missing the required parameter 'accountId' when calling invalidatesCacheByAccount");

        final String uri = "/1.0/kb/admin/cache/accounts/{accountId}"
          .replaceAll("\\{" + "accountId" + "\\}", accountId.toString());


        final RequestOptionsBuilder inputOptionsBuilder = inputOptions.extend();
        inputOptionsBuilder.withHeader(KillBillHttpClient.HTTP_HEADER_ACCEPT, "application/json");
        final RequestOptions requestOptions = inputOptionsBuilder.build();

        httpClient.doDelete(uri, requestOptions);
    }


    public void invalidatesCacheByTenant(final RequestOptions inputOptions) throws KillBillClientException {

        final String uri = "/1.0/kb/admin/cache/tenants";


        final RequestOptionsBuilder inputOptionsBuilder = inputOptions.extend();
        inputOptionsBuilder.withHeader(KillBillHttpClient.HTTP_HEADER_ACCEPT, "application/json");
        final RequestOptions requestOptions = inputOptionsBuilder.build();

        httpClient.doDelete(uri, requestOptions);
    }

    public void putInRotation(final RequestOptions inputOptions) throws KillBillClientException {

        final String uri = "/1.0/kb/admin/healthcheck";


        final RequestOptionsBuilder inputOptionsBuilder = inputOptions.extend();
        inputOptionsBuilder.withHeader(KillBillHttpClient.HTTP_HEADER_ACCEPT, "application/json");
        final RequestOptions requestOptions = inputOptionsBuilder.build();

        httpClient.doPut(uri, null, requestOptions);
    }


    public void putOutOfRotation(final RequestOptions inputOptions) throws KillBillClientException {

        final String uri = "/1.0/kb/admin/healthcheck";


        final RequestOptionsBuilder inputOptionsBuilder = inputOptions.extend();
        inputOptionsBuilder.withHeader(KillBillHttpClient.HTTP_HEADER_ACCEPT, "application/json");
        final RequestOptions requestOptions = inputOptionsBuilder.build();

        httpClient.doDelete(uri, requestOptions);
    }

    public void triggerInvoiceGenerationForParkedAccounts(final Map<String, String> pluginProperty, final RequestOptions inputOptions) throws KillBillClientException {
        triggerInvoiceGenerationForParkedAccounts(Long.valueOf(0), Long.valueOf(100), pluginProperty, inputOptions);
    }

    public void triggerInvoiceGenerationForParkedAccounts(final Long offset, final Long limit, final Map<String, String> pluginProperty, final RequestOptions inputOptions) throws KillBillClientException {

        final String uri = "/1.0/kb/admin/invoices";

        final Map<String, Collection<String>> queryParams = new HashMap<>(inputOptions.getQueryParams());
        if (offset != null) {
            addToMapValues(queryParams, "offset", List.of(String.valueOf(offset)));
        }
        if (limit != null) {
            addToMapValues(queryParams, "limit", List.of(String.valueOf(limit)));
        }
        if (pluginProperty != null) {
            addToMapValues(queryParams, "pluginProperty", Converter.convertPluginPropertyMap(pluginProperty));
        }

        final RequestOptionsBuilder inputOptionsBuilder = inputOptions.extend();
        final Boolean followLocation = Objects.requireNonNullElse(inputOptions.getFollowLocation(), Boolean.TRUE);
        inputOptionsBuilder.withFollowLocation(followLocation);
        inputOptionsBuilder.withQueryParams(queryParams);
        inputOptionsBuilder.withHeader(KillBillHttpClient.HTTP_HEADER_ACCEPT, "application/json");
        inputOptionsBuilder.withHeader(KillBillHttpClient.HTTP_HEADER_CONTENT_TYPE, "application/json");
        final RequestOptions requestOptions = inputOptionsBuilder.build();

        httpClient.doPost(uri, null, requestOptions);
    }

    public void updatePaymentTransactionState(final UUID paymentId, final UUID paymentTransactionId, final AdminPayment body, final RequestOptions inputOptions) throws KillBillClientException {
        checkNotNull(paymentId, "Missing the required parameter 'paymentId' when calling updatePaymentTransactionState");
        checkNotNull(paymentTransactionId, "Missing the required parameter 'paymentTransactionId' when calling updatePaymentTransactionState");
        checkNotNull(body, "Missing the required parameter 'body' when calling updatePaymentTransactionState");

        final String uri = "/1.0/kb/admin/payments/{paymentId}/transactions/{paymentTransactionId}"
          .replaceAll("\\{" + "paymentId" + "\\}", paymentId.toString())
          .replaceAll("\\{" + "paymentTransactionId" + "\\}", paymentTransactionId.toString());


        final RequestOptionsBuilder inputOptionsBuilder = inputOptions.extend();
        inputOptionsBuilder.withHeader(KillBillHttpClient.HTTP_HEADER_ACCEPT, "application/json");
        inputOptionsBuilder.withHeader(KillBillHttpClient.HTTP_HEADER_CONTENT_TYPE, "application/json");
        final RequestOptions requestOptions = inputOptionsBuilder.build();

        httpClient.doPut(uri, body, requestOptions);
    }

}
